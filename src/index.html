<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation Project</title>
    <link rel="stylesheet" href="styles.css">
    <!-- <link rel="icon" href="/images/favicon.png" type="image/png"> -->
</head>

<body>
    <script src="./main.js" type="module"></script>
    <section>
        <h1>Live Simulation <em>(no shaders)</em></h1>
        <div>
            <em id="gridSize">--</em>
        </div>
        <div id="outerSim">
            
            <div id="canvasContainer" style="position: static;">
                <canvas id="fluidCanvas" style="position: absolute;"></canvas>
                <canvas id="UICanvas" style="position: absolute;"></canvas>
            </div>
            <div id="controls">
                <div class="control-container">
                    <label style="display: block;" for="gridResolution">Grid Resolution (Side Length): </label>
                    <input type="range" id="gridResolution" min="1" max="200" value="50">
                    <span id="gridResolutionValue">50</span>
                </div>
    
                <div class="control-container">
                    <label style="display: block;" for="totalTimestamps">Total Timestamps: </label>
                    <input type="range" id="totalTimestamps" min="1" max="1000" value="100">
                    <span id="totalTimestampsValue">100</span>
                </div>
            </div>
        </div>
        <div>
            <p id="stepCounter">Step 0</p>
            <p id="performanceIndicator">Average time per step (over last 100 steps): -- ms</p>
            <p id="memInd">Memory Usage: --</p>
        </div>
        <div id="buttonContainer" style="margin-top: 20px;">
            <button id="startButton">Start</button>
            <button id="pauseButton" disabled>Pause</button>
            <button id="resetButton">Reset</button>
            <button id="advanceButton">Advance By 1 Frame</button>
            <button id="addCircleButton">Add Circle</button>
        </div>
        <div id="instructionBox" style="border: 1px solid #ccc; padding: 10px; width: 300px;" hidden>
            Instructions will appear here.
        </div>
    </section>
    <section id="project-description">
        <h1>Fluid Simulation</h1>
        <section id="background-information">
            <h2>Background Information</h2>
            <p class="background-text">
                The Lattice Boltzmann Method (LBM) is a numerical approach used for simulating fluid dynamics. It
                operates on a discretized lattice grid where each cell holds values for fluid density and velocity
                distributions. LBM differs from traditional computational fluid dynamics (CFD) methods, as it models the
                microscopic particle interactions rather than directly solving macroscopic fluid equations. By doing so,
                LBM is particularly well-suited for simulating complex fluid behavior and is efficiently parallelizable,
                making it a popular choice for GPU-based simulations.
            </p>
        </section>


        <section>
            <h2>Problem Domain</h2>
            <p>The importance of finding an optimal solution depends on the application:</p>
            <ul>
                <li><strong>Engineering:</strong> Critical for improving designs in aerospace, automotive, and renewable
                    energy, where efficiency, safety, and performance are paramount.</li>
                <li><strong>Manufacturing:</strong> Essential for reducing defects and optimizing processes like
                    casting, molding, and chemical mixing.</li>
                <li><strong>Games and VFX:</strong> Realism and computational efficiency are more important than strict
                    optimality, enabling engaging interactions and lifelike animations.</li>
            </ul>
            <p>Optimal solutions are vital for technical accuracy in engineering and manufacturing but less so in
                creative domains like entertainment.</p>
        </section>


        <section>
            <h2>Inputs and Outputs</h2>
            <h3>Inputs</h3>
            <ul>
                <li>Initial state
                    <ul>
                        <li>Size of grid</li>
                        <li>Random noise of velocity</li>
                        <li>Initial significant velocity of some particles <em>(white circle)</em></li>
                        <li>Collidable geometry mask. Initial circle object.</li>
                    </ul>
                </li>
                <li>Live User input
                    <ul>
                        <li>Adding collidable geometry</li>
                    </ul>
                </li>
            </ul>
            <h3>Outputs</h3>
            <ul>
                <li>Velocity at each lattice site</li>
                <li>Simulation runs for certain number of timesteps</li>
            </ul>
        </section>

        <section id="algorithm-description">
            <h2>Algorithm Description</h2>
            <h3 id="overview">Overview</h3>
            <p>While simulation is running:</p>
            <ul>
                <li><a href="#collision-step">Collision step (Relaxation)</a></li>
                <li><a href="#streaming">Streaming step (Propagate to neighboring cells)</a></li>
                <li><a href="#handle-boundaries">Apply boundary conditions</a></li>
                <li><a href="#update-macroscopic">Update macroscopic velocity and density</a></li>
                <li><a href="#render">Render the updated fluid field using Three.js</a></li>
            </ul>

            <h3 id="initialization">Initialization</h3>
            <p>Initialize lattice grid with dimensions NxM</p>
            <p>For each cell in the grid:</p>
            <ul>
                <li>Initialize fluid density and velocity distribution (9 velocity directions for 2D)</li>
                <li>Apply boundary conditions (walls, inlets, outlets)</li>
            </ul>
            <p>Set fluid relaxation time (tau)</p>
            <p>Set speed of sound (cs)</p>
            <p>Define lattice velocity vectors (9 directions for D2Q9 model)</p>
            <p>Time complexity of this step: O(NxMx9)=O(NxM)</p>

            <h3 id="collision-step">Collision Step</h3>
            <p>For each cell in the grid:</p>
            <ul>
                <li>Compute macroscopic density (rho) and velocity (u) from the distribution functions</li>
                <li>For each velocity direction:
                    <ul>
                        <li>Compute equilibrium distribution function (f_eq)</li>
                        <li>Relax towards equilibrium:
                            <pre>f_i_new = f_i_old + (f_eq - f_i_old) / tau</pre>
                        </li>
                    </ul>
                </li>
            </ul>
            <p>Time complexity of this step: O(NxMx9)=O(NxM)</p>


            <h3 id="streaming">Streaming</h3>
            <p>For each cell in the grid:</p>
            <ul>
                <li>For each velocity direction:
                    <ul>
                        <li>Move distribution function to neighboring cell in the direction of the velocity vector</li>
                    </ul>
                </li>
            </ul>
            <p>Time complexity of this step: O(NxMx9)=O(NxM)</p>

            <h3 id="handle-boundaries">Handle Boundaries</h3>
            <p>For each boundary cell (could be entire grid):</p>
            <ul>
                <li>Apply no-slip boundary conditions:
                    <ul>
                        <li>Reverse the velocity at the wall (bounce-back)</li>
                    </ul>
                </li>
                <li>Apply periodic boundaries (if necessary):
                    <ul>
                        <li>Wrap fluid from one side to the other</li>
                    </ul>
                </li>
            </ul>
            <p>Time complexity of this step: O(NxM), worst case is that entire grid is covered in objects.</p>

            <h3 id="update-macroscopic">Update Macroscopic Cell Variables</h3>
            <p>For each cell in the grid:</p>
            <ul>
                <li>Compute macroscopic velocity and density from the new distribution functions</li>
            </ul>
            <p>Time complexity of this step: O(NxM)</p>

            <h3 id="render">Render</h3>
            <p>For each cell in the grid:</p>
            <ul>
                <li>Compute the color or size of a particle based on the density or velocity magnitude</li>
                <li>Update the position of particles or arrows based on velocity direction</li>
                <li>Render the scene using Three.js</li>
            </ul>
            <p>Time complexity of this step: O(NxM)</p>
        </section>


        <section>
            <h2>Time Complexity Analysis - Non-shader algorithm</h2>
            <ul>
                <li><strong>Initialization:</strong> <code>O(N &times; M)</code></li>
                <li><strong>Collision Step:</strong> <code>O(N &times; M)</code></li>
                <li><strong>Streaming:</strong> <code>O(N &times; M)</code></li>
                <li><strong>Handle Boundaries:</strong> <code>O(N + M)</code></li>
                <li><strong>Update Macroscopic Variables:</strong> <code>O(N &times; M)</code></li>
            </ul>
            <p>The overall complexity for a single timestep is dominated by <code>O(N &times; M)</code>, as boundary
                handling is typically a minor contribution.</p>
        </section>

        <section>
            <h2>Runtime Analysis <em>(no shaders)</em></h2>
            <table border="1px">
                <thead>
                    <tr>
                        <th>Input Size (lattice sites)</th>
                        <th>Avg. Runtime of 1 Step (ms)</th>
                        <th>Memory (kB)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>2,500</td>
                        <td>10.68</td>
                        <td>90.33</td>
                    </tr>
                    <tr>
                        <td>10,000</td>
                        <td>11.78</td>
                        <td>361.33</td>
                    </tr>
                    <tr>
                        <td>22,500</td>
                        <td>21.69</td>
                        <td>812.99</td>
                    </tr>
                    <tr>
                        <td>40,000</td>
                        <td>39.40</td>
                        <td>1445.31</td>
                    </tr>
                    <tr>
                        <td>160,000</td>
                        <td>6.5 (simulation update) ~470 (rendering)</td>
                        <td>5781.25</td>
                    </tr>
                </tbody>
            </table>
        </section>

    </section>


    <h2>References</h2>
    <ul>
        <li><a href="https://en.wikipedia.org/wiki/Navier%E2%80%93Stokes_equations" target="_blank">Navier-Stokes</a>
        </li>
        <li><a href="https://shahriyarshahrabi.medium.com/gentle-introduction-to-fluid-simulation-for-programmers-and-technical-artists-7c0045c40bac"
                target="_blank">Simulation Grid</a></li>
        <li><a href="https://www.reddit.com/r/threejs/comments/thx35q/water_simulation_in_three_js/"
                target="_blank">Reddit posts with past projects</a></li>
        <li><a href="https://github.com/PavelDoGreat/WebGL-Fluid-Simulation" target="_blank">Github for webgl 2D fluid
                simulation with pretty colors</a></li>
        <li><a href="https://www.divecae.com/resources/cfd-methods" target="_blank">Types of methods and their uses</a>
        </li>
        <li><a href="https://www.fidelisfea.com/post/navier-stokes-vs-lattice-boltzmann-for-cfd-a-comparative-analysis#:~:text=The%20Navier%2DStokes%20equations%20describe,fluid%20particles%20to%20macroscopic%20scales."
                target="_blank">Comparison of lattice-boltzmann and navier-stokes</a></li>
    </ul>

</body>

</html>