<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fluid Simulation</title>
    <link rel="stylesheet" href="simStyles.css">
    <!-- <link rel="icon" href="/images/favicon.png" type="image/png"> -->
</head>

<body>
    <canvas id="fluidCanvas"></canvas>
    <script src="./main5.js" type="module"></script>
	<script id="multiply" type="x-shader/x-fragment">
		uniform sampler2D uTexture;

		void main() {
			vec4 color = texture2D(uTexture, gl_FragCoord.xy / vec2(128, 128));
			gl_FragColor = color * vec4(0.5, 1.0, 0.5, 1.0); // Multiply color by greenish color
		}
	</script>
	
	<script id="invert" type="x-shader/x-fragment">
		uniform sampler2D uTexture;

		void main() {
			vec4 color = texture2D(uTexture, gl_FragCoord.xy / vec2(128, 128));  // assuming 512x512 texture resolution
			gl_FragColor = vec4(1.0 - color.rgb, 1.0);  // Invert the color
		}
	</script>

	<script id ="boundary" type="x-shader/x-fragment">
		uniform uResolution;
		uniform uTexture;
		const uint x = gl_GlobalInvocationID.x;
		const uint y = gl_GlobalInvocationID.y;

		uint indexOfDirection(int i, int j) {
			return 3*(j+1) + (i+1);
		}
		
		uint indexOfLatticeCell(uint x, uint y) {
			return 9*uResolution*y + 9*x;
		}

		// Assuming `f` is a 2D array holding the distribution functions at each lattice point
		// `i` is the index of the direction (0 to 8 for D2Q9)
		vec2 boundary_normal = vec2(0.0, 1.0); // Normal vector pointing to the boundary (e.g., top boundary)
		
		void applyNoSlipBoundaryCondition() {
			for ( int i = -1; i <= 1; ++i ) {
				for ( int j = -1; j <= 1; ++j ) {
					if (isAtBoundary(x+i, x+j)) {
						int opposite_i = getOppositeDirection(i); // Opposite direction of the lattice
						f[i] = f[opposite_i]; // Bounce-back: reverse the distribution function
					}
				}
			}
		}
		
		bool isAtBoundary() {
			// Check if the current grid cell is at the boundary
			// This could be based on position in the grid (e.g., y == grid_height - 1)
			return (position.y == grid_height - 1);
		}
		
		int getOppositeDirection(int i) {
			// Return the index of the opposite direction for D2Q9
			int opposite[9] = {0, 3, 4, 1, 2, 5, 6, 7, 8};
			return opposite[i];
		}		
	</script>

	<script id="collision" type="x-shader/x-fragment">
		void applyCollisionStep(float tau) {
			vec2 velocity = computeMacroscopicVelocity(); // Calculate the macroscopic velocity
			for (int i = 0; i < 9; i++) {
				// Compute equilibrium distribution function for each direction
				float feq = computeEquilibriumDistribution(i, velocity);
				
				// Relaxation step
				f[i] = f[i] - (1.0 / tau) * (f[i] - feq);
			}
		}
		
		vec2 computeMacroscopicVelocity() {
			// Compute the macroscopic velocity from the distribution functions
			vec2 velocity = vec2(0.0, 0.0);
			float rho = 0.0;
			
			for (int i = 0; i < 9; i++) {
				rho += f[i]; // Sum of all distribution functions gives density
				velocity += f[i] * e[i]; // Velocity is weighted sum of distribution functions and lattice directions
			}
			
			velocity /= rho; // Normalize by density
			return velocity;
		}
		
		float computeEquilibriumDistribution(int i, vec2 velocity) {
			// Calculate the equilibrium distribution function for the i-th direction
			float ci = dot(velocity, e[i]);
			float usqr = dot(velocity, velocity);
			
			return w[i] * (1.0 + ci / (c_s * c_s) + 0.5 * (ci * ci) / (c_s * c_s * c_s * c_s) - 0.5 * usqr / (c_s * c_s));
		}		
	</script>

	<script id="streaming" type="x-shader/x-fragment">
		void applyStreamingStep() {
			for (int i = 0; i < 9; i++) {
				// Stream the distribution functions to neighboring cells
				vec2 neighbor = position + e[i]; // Move in the direction of e[i]
				fNew[neighbor] = f[position];  // Store the new value in the neighboring grid cell
			}
		}		
	</script>

	<script id="velocityColor" type="x-shader/x-fragment">
		uniform sampler2D velocityTex;  // Texture holding the velocity field
		uniform vec2 resolution;        // Resolution of the texture

		out vec4 fragColor;  // The final color to be rendered

		void main() {
			// Get the current texture coordinates (for each pixel on the screen)
			vec2 texCoords = gl_FragCoord.xy / resolution;
			
			// Fetch the velocity vector (assuming velocity is stored in two channels: x and y)
			vec2 velocity = texture(velocityTex, texCoords).xy;
			
			// Compute the speed (magnitude of velocity)
			float speed = length(velocity);
			
			// Normalize velocity direction to get an angle (for coloring based on direction)
			float angle = atan(velocity.y, velocity.x) / (2.0 * 3.14159);  // Normalize to [0, 1]
			
			// Map angle to hue (color wheel), and speed to brightness (color intensity)
			vec3 color = vec3(0.5 + 0.5 * cos(angle * 6.2831),  // hue from angle
							1.0,  // full saturation
							speed); // brightness based on speed
			
			fragColor = vec4(color, 1.0);
		}
	</script>

    
	<!-- <script id="fragShader" type="shader-code">
		uniform vec2 res;//The width and height of our scsreen
		uniform sampler2D bufferTexture;//Our input texture
		uniform vec3 smokeSource;//The x,y are the posiiton. The z is the power/density
		void main() {
	        vec2 pixel = gl_FragCoord.xy / res.xy;
	        gl_FragColor = texture2D( bufferTexture, pixel );

	        //Get the distance of the current pixel from the smoke source
	        float dist = distance(smokeSource.xy,gl_FragCoord.xy);
	        //Generate smoke when mouse is pressed
			gl_FragColor.rgb += smokeSource.z * max(30.0-dist,0.0);
  
     //Smoke diffuse
	        float xPixel = 1.0/res.x;//The size of a single pixel
	        float yPixel = 1.0/res.y;
	        vec4 rightColor = texture2D(bufferTexture,vec2(pixel.x+xPixel,pixel.y));
	        vec4 leftColor = texture2D(bufferTexture,vec2(pixel.x-xPixel,pixel.y));
	        vec4 upColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y+yPixel));
	        vec4 downColor = texture2D(bufferTexture,vec2(pixel.x,pixel.y-yPixel));
//Diffuse equation
	        float factor = 8.0 * 0.016 * (leftColor.r + rightColor.r + downColor.r * 3.0 + upColor.r - 6.0 * gl_FragColor.r);
		 
	        //Account for low precision of texels
	        float minimum = 0.003;
			if(factor >= -minimum && factor < 0.0) factor = -minimum;

			gl_FragColor.rgb += factor;
		 }
	</script> -->
    <!-- <script id="fragShader" src="./shaders/fragmentShader.glsl" type="shaderCode"></script> -->

    <p>
        <a href="index.html">Home Page</a>
    </p>
</body>

</html>